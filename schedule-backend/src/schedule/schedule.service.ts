import { Injectable } from "@nestjs/common";import { HttpService } from "@nestjs/axios";import { Day } from "./models/day.model";import { lastValueFrom } from "rxjs";import { AxiosResponse } from "axios";import { SearchParams } from "./models/search-params.model";import { parse } from "node-html-parser";import { Lesson } from "./models/lesson.model";// eslint-disable-next-line @typescript-eslint/no-var-requiresconst encoding = require("encoding");@Injectable()export class ScheduleService {  constructor(private http: HttpService) {  }  async getSchedule(searchParams: SearchParams[]): Promise<Day[]> {    let parsedDays: Day[] = [];    for (const params of searchParams) {      const response = await this.getResponseHTML(params);      const convertedByteArray = encoding.convert(response.data, "UTF-8", "windows-1251");      parsedDays = parsedDays.concat(this.parseDaysFromHTML(convertedByteArray.toString(), params.group));    }    return this.joinSameDays(parsedDays);  }  private getResponseHTML(searchParams: SearchParams): Promise<AxiosResponse> {    // if groupName contains cyrillic then turn it to hex    const groupName = searchParams.group.match(/[\u0400-\u04FF]/)      ? this.groupNameToHex(searchParams.group)      : searchParams.group;    const rawSearchParams =      // `faculty=${searchParams.faculty}&` +      `group=${groupName}&` +      `teacher=${searchParams.teacher}&` +      `sdate=${searchParams.startDate}&` +      `edate=${searchParams.endDate}`;    return lastValueFrom(this.http.post(      "http://195.95.232.162:8082/cgi-bin/timetable.cgi?n=700",      rawSearchParams, {        responseType: "arraybuffer",      },    ));  }  private parseDaysFromHTML(html: string, groupName: string): Day[] {    const parsedDays: Day[] = [];    const root = parse(html, {      blockTextElements: { script: false },    });    // parse days    const rawDaysOfTheWeekAndDate = root.querySelectorAll("div.row+h4, div.col-md-6 h4");    rawDaysOfTheWeekAndDate.forEach((element, index) => {      parsedDays[index] = new Day();      parsedDays[index].name = element.querySelector("small").innerHTML;      parsedDays[index].date = element.innerHTML        .match(/^(.*?)<small>/)[1]        .trim();    });    // parse lessons    let i = -1, offset = 0;    const allRawLessons = root.querySelectorAll("tr");    allRawLessons.forEach((rawLesson) => {      const lessonOrder = +rawLesson.querySelector("td").innerHTML - 1;      if (lessonOrder === 0) {        i++;        offset = 0;      }      const lessonIndex = lessonOrder + offset;      parsedDays[i].lessons[lessonIndex] = new Lesson();      parsedDays[i].lessons[lessonIndex].order =        +rawLesson.querySelectorAll("td")[0]          .innerHTML;      parsedDays[i].lessons[lessonIndex].time =        rawLesson.querySelectorAll("td")[1]          .innerHTML          .replace(/<br>/, ":");      parsedDays[i].lessons[lessonIndex].type =        rawLesson.querySelectorAll("td")[2]          .innerHTML          .match(/^\((.*?)\)<br>/)?.[1];      parsedDays[i].lessons[lessonIndex].name =        rawLesson.querySelectorAll("td")[2]          .innerHTML          .match(/<br>(.*?)<br>/)?.[1]          .trim();      parsedDays[i].lessons[lessonIndex].groups =        rawLesson.querySelectorAll("td")[2]          .innerHTML          .match(/<br>.*?<br>(.*?)<br>/)?.[1]          .trim() || groupName;      const isMoreThanOneLesson =        rawLesson.querySelectorAll("td")[2]          .querySelectorAll("div.link")          .length > 1;      if (isMoreThanOneLesson) {        offset += 1;        parsedDays[i].lessons[lessonIndex + 1] = new Lesson();        parsedDays[i].lessons[lessonIndex + 1].order = parsedDays[i].lessons[lessonIndex].order;        parsedDays[i].lessons[lessonIndex + 1].time = parsedDays[i].lessons[lessonIndex].time;        parsedDays[i].lessons[lessonIndex + 1].type =          rawLesson.querySelectorAll("td")[2]            .innerHTML            .match(/<\/div> <br>\((.*?)\)<br>/)?.[1]            .trim();        parsedDays[i].lessons[lessonIndex + 1].name =          rawLesson.querySelectorAll("td")[2]            .innerHTML            .match(/<br>\(.*?\)<br>(.*?)<br>/)?.[1]            .trim();        parsedDays[i].lessons[lessonIndex + 1].groups =          rawLesson.querySelectorAll("td")[2]            .innerHTML            .match(/<\/div> <br>(.*?)<br>(.*?)<br>(?<group>.*?)<br> <div class='link'> <\/div>/)            .groups.group.trim() || groupName;      }    });    return parsedDays;  }  private joinSameDays(days: Day[]): Day[] {    days.forEach((day) => {      day.lessons = day.lessons.filter((lesson) => {        return lesson.type && lesson.name;      });      // days.forEach((element) => {      //   if (day.date === element.date && day.lessons[0].name !== element.lessons[0].name) {      //     days.splice(days.indexOf(day), 1);      //   }      // });    });    return days;  }  private groupNameToHex(groupName: string): string {    const matches = [...groupName.matchAll(/[\u0400-\u04FF]|\+/g)];    let hexString = groupName;    for (const match of matches) {      const win1251ByteArray = encoding.convert(match[0], "windows-1251", "UTF-8");      const hexCharacter = Buffer.from(win1251ByteArray).toString("hex");      hexString = hexString.replace(match[0], "%" + hexCharacter.toUpperCase());    }    return hexString;  }}